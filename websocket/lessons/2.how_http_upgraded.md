Q1: How http is upgraded? 

## Simple Explanation: HTTP to WebSocket Upgrade Process

The HTTP upgrade is like transforming a one-time phone call into a permanent phone line. Here's how it works:

### The HTTP Upgrade Handshake

WebSocket connections start as regular HTTP requests, then get "upgraded" to WebSocket protocol through a special handshake process.

### Step-by-Step Process

#### Step 1: Client Sends HTTP Request with Upgrade Headers

The client sends a special HTTP request that says "I want to upgrade to WebSocket":

```
GET /ws HTTP/1.1
Host: localhost:8089
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
Origin: http://localhost:8089
```

**Key Headers:**
- `Upgrade: websocket` - Requests protocol upgrade
- `Connection: Upgrade` - Confirms the upgrade request
- `Sec-WebSocket-Key` - Random 16-byte value, base64 encoded (security measure)
- `Sec-WebSocket-Version: 13` - WebSocket protocol version
- `Origin` - Where the request came from (for security checks)

#### Step 2: Server Validates the Request

The server checks:
1. **Is it a WebSocket request?** - Checks for `Upgrade: websocket` header
2. **Is the key valid?** - Verifies `Sec-WebSocket-Key` is properly formatted
3. **Origin check** - Validates the `Origin` header (security)
4. **Version check** - Ensures WebSocket version is supported

#### Step 3: Server Computes Response Key

The server takes the client's `Sec-WebSocket-Key` and:
1. Appends a magic string: `"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"`
2. Computes SHA-1 hash
3. Base64 encodes the result
4. This becomes `Sec-WebSocket-Accept`

**Why?** This proves the server understands WebSocket protocol and prevents accidental upgrades.

#### Step 4: Server Sends HTTP 101 Response

The server responds with:

```
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

**HTTP 101** = "I'm switching protocols now!"

#### Step 5: Connection is Upgraded

After the 101 response:
- The underlying TCP connection stays open
- Protocol switches from HTTP to WebSocket
- Both sides can now send WebSocket frames (not HTTP requests/responses)
- Connection becomes bidirectional and persistent

---

Q2: Show the code related to it and explain it.

## Code Explanation: HTTP Upgrade Implementation

### 1. The Upgrader Configuration

**Location:** `main.go` lines 13-20

```go
// WebSocketå‡çº§å™¨
var upgrader = websocket.Upgrader{
	ReadBufferSize:  1024,
	WriteBufferSize: 1024,
	CheckOrigin: func(r *http.Request) bool {
		return true // å…è®¸æ‰€æœ‰æ¥æºï¼ˆç”Ÿäº§ç¯å¢ƒåº”è¯¥é™åˆ¶ï¼‰
	},
}
```

**What it does:**
- `ReadBufferSize: 1024` - Buffer size for reading WebSocket messages (1KB)
- `WriteBufferSize: 1024` - Buffer size for writing WebSocket messages (1KB)
- `CheckOrigin` - Function that validates the `Origin` header
  - Returns `true` = allow connection (currently allows all origins)
  - In production, should check if origin is from allowed domains

**Why CheckOrigin matters:**
- Prevents Cross-Site WebSocket Hijacking (CSWSH) attacks
- Should validate `r.Header.Get("Origin")` against allowed list
- Current code allows all origins (convenient for development, unsafe for production)

### 2. The Upgrade Call

**Location:** `main.go` lines 139-145

```go
// å¤„ç†WebSocketè¿æ¥
func (s *Server) HandleWebSocket(w http.ResponseWriter, r *http.Request) {
	// å‡çº§HTTPè¿æ¥ä¸ºWebSocket
	conn, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		log.Printf("WebSocketå‡çº§å¤±è´¥: %v", err)
		return
	}
	// ... rest of the function
}
```

**What `upgrader.Upgrade()` does internally:**

1. **Validates Request Headers:**
   ```go
   // Checks for required headers:
   // - Upgrade: websocket
   // - Connection: Upgrade  
   // - Sec-WebSocket-Key (must be base64, 16 bytes)
   // - Sec-WebSocket-Version: 13
   ```

2. **Calls CheckOrigin:**
   ```go
   if !upgrader.CheckOrigin(r) {
       return error("origin not allowed")
   }
   ```

3. **Computes Sec-WebSocket-Accept:**
   ```go
   key := r.Header.Get("Sec-WebSocket-Key")
   magicString := "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
   hash := sha1.Sum([]byte(key + magicString))
   accept := base64.StdEncoding.EncodeToString(hash[:])
   ```

4. **Sends HTTP 101 Response:**
   ```go
   w.WriteHeader(http.StatusSwitchingProtocols) // 101
   w.Header().Set("Upgrade", "websocket")
   w.Header().Set("Connection", "Upgrade")
   w.Header().Set("Sec-WebSocket-Accept", accept)
   w.Header().Set("Sec-WebSocket-Protocol", protocol) // if provided
   ```

5. **Takes Over HTTP Connection:**
   - Hijacks the underlying TCP connection
   - Converts `http.ResponseWriter` to WebSocket connection
   - Returns `*websocket.Conn` for bidirectional communication

### 3. What Happens After Upgrade

**Location:** `main.go` lines 147-171

```go
// åˆ›å»ºå®¢æˆ·ç«¯
client := &Client{
	ID:       uuid.New().String(),
	Conn:     conn,  // This is now a WebSocket connection, not HTTP!
	Send:     make(chan []byte, 256),
	Channels: make(map[string]bool),
}

// æ³¨å†Œå®¢æˆ·ç«¯
s.register <- client

// å‘é€è¿æ¥ç¡®è®¤æ¶ˆæ¯
response := Response{
	ClientID: client.ID,
	Action:   "connect",
	Code:     200,
	Msg:      "success",
}
data, _ := json.Marshal(response)
client.Send <- data  // Sends WebSocket frame, not HTTP response!

// å¯åŠ¨goroutineå¤„ç†è¯»å†™
go s.writePump(client)  // Reads from WebSocket
go s.readPump(client)   // Writes to WebSocket
```

**Key Points:**
- `conn` is now a `*websocket.Conn`, not an HTTP connection
- Messages are sent as WebSocket frames, not HTTP responses
- Connection stays open for bidirectional communication
- Two goroutines handle reading and writing concurrently

### 4. Reading from Upgraded Connection

**Location:** `main.go` lines 174-199

```go
func (s *Server) readPump(client *Client) {
	defer func() {
		s.unregister <- client
		client.Conn.Close()
	}()

	for {
		_, message, err := client.Conn.ReadMessage()  // Reads WebSocket frame
		if err != nil {
			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
				log.Printf("è¯»å–é”™è¯¯: %v", err)
			}
			break
		}
		// Process WebSocket message...
	}
}
```

**What `ReadMessage()` does:**
- Reads WebSocket frame from the connection
- Handles WebSocket protocol details (masking, opcodes, etc.)
- Returns the actual message payload
- Not HTTP request parsing!

### 5. Writing to Upgraded Connection

**Location:** `main.go` lines 202-220

```go
func (s *Server) writePump(client *Client) {
	defer client.Conn.Close()

	for {
		select {
		case message, ok := <-client.Send:
			if !ok {
				client.Conn.WriteMessage(websocket.CloseMessage, []byte{})
				return
			}

			if err := client.Conn.WriteMessage(websocket.TextMessage, message); err != nil {
				log.Printf("å†™å…¥é”™è¯¯: %v", err)
				return
			}
		}
	}
}
```

**What `WriteMessage()` does:**
- Wraps data in WebSocket frame format
- Handles WebSocket protocol details
- Sends frame over the persistent connection
- Not HTTP response writing!

---

## Visual Flow of HTTP Upgrade

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client  â”‚                              â”‚ Server  â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                              â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚                                       â”‚
     â”‚  1. HTTP GET /ws                      â”‚
     â”‚     Upgrade: websocket                â”‚
     â”‚     Connection: Upgrade               â”‚
     â”‚     Sec-WebSocket-Key: xyz...        â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚                                       â”‚
     â”‚                                       â”‚ 2. Validate headers
     â”‚                                       â”‚    CheckOrigin()
     â”‚                                       â”‚
     â”‚                                       â”‚ 3. Compute accept key
     â”‚                                       â”‚    SHA1(key + magic)
     â”‚                                       â”‚
     â”‚  4. HTTP 101 Switching Protocols      â”‚
     â”‚     Upgrade: websocket                â”‚
     â”‚     Sec-WebSocket-Accept: abc...     â”‚
     â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
     â”‚                                       â”‚
     â”‚  âœ… CONNECTION UPGRADED!              â”‚
     â”‚  (Now using WebSocket protocol)      â”‚
     â”‚                                       â”‚
     â”‚  5. WebSocket Frame (text message)   â”‚
     â”‚     {"action": "subscribe", ...}     â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚                                       â”‚
     â”‚  6. WebSocket Frame (text message)   â”‚
     â”‚     {"clientId": "123", ...}          â”‚
     â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
     â”‚                                       â”‚
     â”‚  ğŸ”„ Bidirectional communication      â”‚
     â”‚  (No more HTTP requests/responses)   â”‚
     â”‚                                       â”‚
```

---

## Key Differences: HTTP vs WebSocket

| Aspect | HTTP | WebSocket (After Upgrade) |
|--------|------|---------------------------|
| **Connection** | Closes after response | Stays open |
| **Communication** | Request â†’ Response | Bidirectional frames |
| **Protocol** | HTTP/1.1 | WebSocket (ws://) |
| **Headers** | Full HTTP headers | Minimal WebSocket frame headers |
| **State** | Stateless | Stateful (connection persists) |
| **Use Case** | One-time requests | Real-time, persistent communication |

---

## Important Notes

1. **Upgrade happens once** - After the 101 response, the connection is permanently WebSocket
2. **No more HTTP** - After upgrade, you can't send HTTP requests/responses on this connection
3. **TCP connection persists** - The underlying TCP socket stays open
4. **Security** - Always validate `Origin` in production to prevent CSWSH attacks
5. **Error handling** - If upgrade fails, the HTTP connection is still valid and can send error response

---

## Real-World Analogy

**HTTP Request** = "Can I upgrade this phone call to video call?"
**HTTP 101 Response** = "Yes! Switching to video now..."
**After 101** = Now it's a video call (WebSocket), not a phone call (HTTP) anymore!

The upgrade is a one-time handshake that transforms the connection type permanently.
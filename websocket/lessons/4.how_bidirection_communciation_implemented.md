Q1: How bidirectional communication is implemented?

## Simple Explanation: Bidirectional Communication

Think of bidirectional communication like a two-way radio:
- **One person listens** (readPump) - receives messages
- **One person speaks** (writePump) - sends messages
- **Both happen at the same time** - concurrent goroutines
- **Messages can flow both ways** - client â†” server

### The Two-Pump Architecture

WebSocket enables bidirectional communication, but we need two separate "pumps" (workers) to handle it:

1. **readPump** - Continuously reads messages FROM the client
2. **writePump** - Continuously writes messages TO the client

Both run **concurrently** (in parallel) using goroutines, so they don't block each other.

### How It Works

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client  â”‚                    â”‚ Server  â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚                             â”‚
     â”‚                             â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚                             â”‚  â”‚ readPump    â”‚
     â”‚  Message â†’                  â”‚  â”‚ (goroutine) â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚  â”‚             â”‚
     â”‚                             â”‚  â”‚ Reads from  â”‚
     â”‚                             â”‚  â”‚ WebSocket   â”‚
     â”‚                             â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚                             â”‚
     â”‚                             â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚                             â”‚  â”‚ writePump   â”‚
     â”‚  â† Message                  â”‚  â”‚ (goroutine) â”‚
     â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚             â”‚
     â”‚                             â”‚  â”‚ Writes to   â”‚
     â”‚                             â”‚  â”‚ WebSocket   â”‚
     â”‚                             â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚                             â”‚
     â”‚  âœ… Both directions work    â”‚
     â”‚     simultaneously!         â”‚
```

### Key Components

1. **Two Separate Goroutines**
   - `readPump` - handles incoming messages (client â†’ server)
   - `writePump` - handles outgoing messages (server â†’ client)
   - Run independently, don't wait for each other

2. **Send Channel as Buffer**
   - `client.Send chan []byte` - acts as a queue
   - Multiple parts of code can send messages
   - writePump reads from this channel and sends to client

3. **Direct WebSocket Reading**
   - `readPump` reads directly from `client.Conn`
   - Processes messages immediately
   - Handles errors and disconnections

---

Q2: Show me related code and explain it?

## Code Explanation: Bidirectional Communication Implementation

### 1. Starting Both Pumps

**Location:** `main.go` lines 168-170

```go
// å¯åŠ¨goroutineå¤„ç†è¯»å†™
go s.writePump(client)
go s.readPump(client)
```

**What happens:**
- **`go` keyword** - Starts a new goroutine (lightweight thread)
- **Two goroutines** - One for reading, one for writing
- **Non-blocking** - The `HandleWebSocket` function returns immediately
- **Concurrent execution** - Both pumps run simultaneously

**Why separate goroutines?**
- **Non-blocking**: Reading doesn't block writing, and vice versa
- **Concurrent**: Can read and write at the same time
- **Independent**: If one fails, the other can still work (until connection closes)

### 2. The Send Channel (Message Queue)

**Location:** `main.go` line 151

```go
Send: make(chan []byte, 256),
```

**What it is:**
- A **buffered channel** with capacity of 256 messages
- Acts as a **queue** for outgoing messages
- Multiple goroutines can send to it safely

**Why use a channel?**
- **Thread-safe**: Multiple goroutines can send without race conditions
- **Buffered**: Can hold up to 256 messages before blocking
- **Decoupling**: Separates message creation from message sending

### 3. readPump: Reading FROM Client

**Location:** `main.go` lines 173-199

```go
// è¯»å–æ¶ˆæ¯
func (s *Server) readPump(client *Client) {
	defer func() {
		s.unregister <- client
		client.Conn.Close()
	}()

	for {
		_, message, err := client.Conn.ReadMessage()
		if err != nil {
			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
				log.Printf("è¯»å–é”™è¯¯: %v", err)
			}
			break
		}

		// è§£ææ¶ˆæ¯
		var msg Message
		if err := json.Unmarshal(message, &msg); err != nil {
			log.Printf("æ¶ˆæ¯è§£æå¤±è´¥: %v", err)
			continue
		}

		// å¤„ç†æ¶ˆæ¯
		s.handleMessage(client, &msg)
	}
}
```

**Step-by-step explanation:**

#### A. Defer Cleanup
```go
defer func() {
	s.unregister <- client
	client.Conn.Close()
}()
```
- **Runs when function exits** (when loop breaks)
- **Unregisters client** - removes from server's client list
- **Closes connection** - cleans up WebSocket connection

#### B. Infinite Loop
```go
for {
	_, message, err := client.Conn.ReadMessage()
```
- **Continuously reads** - blocks until message arrives
- **ReadMessage()** - reads a WebSocket frame from connection
- **Returns**: message type, message bytes, error

#### C. Error Handling
```go
if err != nil {
	if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
		log.Printf("è¯»å–é”™è¯¯: %v", err)
	}
	break
}
```
- **Expected errors** - Normal close (CloseGoingAway) or abnormal closure
- **Unexpected errors** - Logged for debugging
- **Break** - Exits loop, triggers defer cleanup

#### D. Message Processing
```go
var msg Message
if err := json.Unmarshal(message, &msg); err != nil {
	log.Printf("æ¶ˆæ¯è§£æå¤±è´¥: %v", err)
	continue  // Skip invalid messages, keep reading
}

s.handleMessage(client, &msg)
```
- **Parse JSON** - Converts bytes to Message struct
- **Handle message** - Routes to appropriate handler (subscribe, unsubscribe, ping)

**Flow:**
```
Client sends message
    â†“
readPump reads from WebSocket
    â†“
Parse JSON
    â†“
handleMessage() processes it
    â†“
(May trigger response via client.Send)
    â†“
Loop continues, waiting for next message
```

### 4. writePump: Writing TO Client

**Location:** `main.go` lines 201-220

```go
// å†™å…¥æ¶ˆæ¯
func (s *Server) writePump(client *Client) {
	defer client.Conn.Close()

	for {
		select {
		case message, ok := <-client.Send:
			if !ok {
				// é€šé“å·²å…³é—­
				client.Conn.WriteMessage(websocket.CloseMessage, []byte{})
				return
			}

			if err := client.Conn.WriteMessage(websocket.TextMessage, message); err != nil {
				log.Printf("å†™å…¥é”™è¯¯: %v", err)
				return
			}
		}
	}
}
```

**Step-by-step explanation:**

#### A. Defer Cleanup
```go
defer client.Conn.Close()
```
- **Closes connection** when function exits
- **Ensures cleanup** even if error occurs

#### B. Select Statement (Channel Receiver)
```go
select {
case message, ok := <-client.Send:
```
- **Waits for messages** - Blocks until message arrives in channel
- **`ok` variable** - `false` if channel is closed
- **Non-blocking alternative** - Could add `default` case for other operations

#### C. Channel Closed Check
```go
if !ok {
	// é€šé“å·²å…³é—­
	client.Conn.WriteMessage(websocket.CloseMessage, []byte{})
	return
}
```
- **Channel closed** - Means client is being unregistered
- **Send close message** - Notifies client connection is closing
- **Return** - Exits function, triggers defer cleanup

#### D. Write Message
```go
if err := client.Conn.WriteMessage(websocket.TextMessage, message); err != nil {
	log.Printf("å†™å…¥é”™è¯¯: %v", err)
	return
}
```
- **WriteMessage()** - Sends WebSocket frame to client
- **TextMessage** - Type of WebSocket frame (text data)
- **Error handling** - Logs and exits on write failure

**Flow:**
```
Some code puts message in client.Send channel
    â†“
writePump receives from channel
    â†“
Writes to WebSocket connection
    â†“
Client receives message
    â†“
Loop continues, waiting for next message
```

### 5. How Messages Are Sent TO Client

Multiple parts of the code can send messages by putting them in `client.Send`:

#### A. Connection Confirmation
**Location:** `main.go` lines 158-166

```go
// å‘é€è¿æ¥ç¡®è®¤æ¶ˆæ¯
response := Response{
	ClientID: client.ID,
	Action:   "connect",
	Code:     200,
	Msg:      "success",
}
data, _ := json.Marshal(response)
client.Send <- data  // Sends to writePump via channel
```

#### B. Subscribe Confirmation
**Location:** `main.go` lines 250-259

```go
// å‘é€è®¢é˜…ç¡®è®¤
response := Response{
	ClientID: client.ID,
	Action:   "subscribe",
	Channel:  channel,
	Code:     200,
	Msg:      "success",
}
data, _ := json.Marshal(response)
client.Send <- data  // writePump will send this
```

#### C. Broadcast Messages
**Location:** `main.go` lines 124-131

```go
for _, client := range clients {
	select {
	case client.Send <- data:  // Send to each client's writePump
	default:
		// å‘é€å¤±è´¥ï¼Œå…³é—­è¿æ¥
		close(client.Send)
		s.unregister <- client
	}
}
```

**Key point:** All these different code paths send to the same `client.Send` channel, and `writePump` handles them all!

### 6. Complete Bidirectional Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Client Connection                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†•
                    WebSocket Conn
                          â†•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Server Side                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  readPump (goroutine)                          â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚
â”‚  â”‚  â”‚ Loop:                                      â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  1. Read from Conn                         â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  2. Parse JSON                             â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  3. handleMessage()                       â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  4. (May put response in client.Send)     â”‚ â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  writePump (goroutine)                         â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚
â”‚  â”‚  â”‚ Loop:                                      â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  1. Receive from client.Send channel       â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  2. Write to Conn                          â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  3. Wait for next message                  â”‚ â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  client.Send chan []byte (buffer)                â”‚  â”‚
â”‚  â”‚  - Connection confirmations                      â”‚  â”‚
â”‚  â”‚  - Subscribe responses                           â”‚  â”‚
â”‚  â”‚  - Broadcast messages                            â”‚  â”‚
â”‚  â”‚  - Pong responses                                â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 7. Example: Complete Message Exchange

**Scenario:** Client subscribes to "news" channel

```
1. Client â†’ Server (via readPump):
   {"action": "subscribe", "channel": "news"}
   
2. readPump receives message
   â†“
3. handleMessage() â†’ handleSubscribe()
   â†“
4. Server adds client to subscriptions["news"]
   â†“
5. Server sends response (via client.Send channel):
   client.Send <- {"clientId": "abc", "action": "subscribe", ...}
   â†“
6. writePump receives from channel
   â†“
7. writePump writes to WebSocket
   â†“
8. Client â† Server:
   {"clientId": "abc", "action": "subscribe", "channel": "news", ...}
```

**Both directions work simultaneously!**

### 8. Why This Architecture?

#### âœ… Advantages:

1. **True Bidirectional**
   - Can read and write at the same time
   - No blocking between directions

2. **Thread Safety**
   - Channel provides safe communication
   - No race conditions

3. **Scalability**
   - Each client has its own pumps
   - Independent of other clients

4. **Error Isolation**
   - Read errors don't affect writing
   - Write errors don't affect reading
   - Each pump handles its own errors

5. **Buffering**
   - Send channel buffers up to 256 messages
   - Prevents blocking when sending multiple messages

#### ğŸ”§ Design Patterns Used:

1. **Producer-Consumer Pattern**
   - Multiple producers (various handlers) â†’ `client.Send` channel â†’ writePump (consumer)

2. **Goroutine Per Connection**
   - Each client gets 2 goroutines (readPump + writePump)
   - Scales well for many concurrent connections

3. **Channel-Based Communication**
   - Decouples message creation from message sending
   - Provides thread-safe communication

### 9. Key Differences from HTTP

| Aspect | HTTP | WebSocket (Bidirectional) |
|--------|------|---------------------------|
| **Communication** | Request â†’ Response (one-way per request) | Both directions simultaneously |
| **Connection** | Closes after response | Stays open |
| **Reading** | One request at a time | Continuous reading loop |
| **Writing** | Response to request | Can write anytime |
| **Concurrency** | Sequential requests | Parallel read/write |

---

## Summary

**Bidirectional communication is implemented using:**

1. **Two concurrent goroutines:**
   - `readPump` - reads FROM client
   - `writePump` - writes TO client

2. **Channel-based messaging:**
   - `client.Send` channel buffers outgoing messages
   - Multiple code paths can send messages
   - writePump consumes from channel

3. **Independent operation:**
   - Reading doesn't block writing
   - Writing doesn't block reading
   - Both happen simultaneously

4. **Error handling:**
   - Each pump handles its own errors
   - Cleanup happens via defer statements
   - Connection closes on error

This architecture enables true real-time bidirectional communication!